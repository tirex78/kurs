/**
 * Фильтрация уникальных элементов массива
 * 
 * Допустим, у нас есть массив arr.
 * 
 * Создайте функцию unique(arr), которая вернёт массив уникальных, не повторяющихся значений массива arr.
 * 
 * Например:
 * 
 * function unique(arr) {
 *    ваш код 
 * }
 * 
 * let values = ["Hare", "Krishna", "Hare", "Krishna",
 *   "Krishna", "Krishna", "Hare", "Hare", ":-O"
 * ];
 * 
 * alert( unique(values) ); // Hare,Krishna,:-O
 * 
 * P.S. Здесь мы используем строки, но значения могут быть любого типа.
 * 
 * P.P.S. Используйте Set для хранения уникальных значений.
 */

let values = ["Hare", "Krishna", "Hare", "Krishna", "Krishna", "Krishna", "Hare", "Hare", ":-O"];

const unique = arr => {
  let set = new Set

  arr.map(el => set.add(el))

  return set

}
//console.log(unique(values))

/**
 * Отфильтруйте анаграммы
 * 
 * Анаграммы – это слова, у которых те же буквы в том же количестве, но они располагаются в другом порядке.
 * 
 * Например:
 * 
 * nap - pan
 * ear - are - era
 * cheaters - hectares - teachers
 * 
 * Напишите функцию aclean(arr), которая возвращает массив слов, очищенный от анаграмм.
 * 
 * Например:
 * 
 * let arr = ["nap", "teachers", "cheaters", "PAN", "ear", "era", "hectares"];
 * 
 * alert( aclean(arr) ); // "nap,teachers,ear" или "PAN,cheaters,era"
 * 
 * Из каждой группы анаграмм должно остаться только одно слово, не важно какое.
 * 
 */
let arr = ["nap", "teachers", "cheaters", "PAN", "ear", "era", "hectares"];

// ! -----------
// Чтобы найти все анаграммы, давайте разобьём каждое слово на буквы и отсортируем их, а потом объединим получившийся массив снова в строку. После этого все анаграммы будут одинаковы.

// Например:

// nap, pan -> anp
// ear, era, are -> aer
// cheaters, hectares, teachers -> aceehrst
// ...

// Мы будем использовать отсортированные строки как ключи в коллекции Map, для того чтобы сопоставить каждому ключу только одно значение:
const aclean = arr => {
  let map = new Map();

  for (let word of arr) {
    // разбиваем слово на буквы, сортируем и объединяем снова в строку
    let sorted = word.toLowerCase().split('').sort().join(''); // (*)
    map.set(sorted, word);
  }

  return Array.from(map.values());
}

// Строка с отсортированными буквами получается в результате цепочки вызовов в строке (*).

// Для удобства, давайте разделим это на несколько строк:

// let sorted = arr[i] // PAN
//   .toLowerCase() // pan
//   .split("") // ["p","a","n"]
//   .sort() // ["a","n","p"]
//   .join(""); // anp

// Два разных слова 'PAN' и 'nap' принимают ту же самую форму после сортировки букв – 'anp'.
// Следующая строчка кода помещает слово в объект Map:
// map.set(sorted, word);
// Если мы когда-либо ещё встретим слово в той же отсортированной форме, тогда это слово перезапишет значение с тем же ключом в объекте. Таким образом, нескольким словам у нас будет всегда соответствовать одна отсортированная форма.
// В конце Array.from(map.values()) принимает итерируемый объект значений объекта Map (в данном случае нам не нужны ключи) и возвращает их в виде массива.
// Также в этом случае вместо Map мы можем использовать простой объект, потому что ключи являются строками.

//console.log(aclean(arr))
/**
 * Перебираемые ключи
 * 
 * Мы хотели бы получить массив ключей map.keys() в переменную и далее работать с ними, например, применить метод .push.
 * 
 * Но это не выходит:
 * 
 * let map = new Map();
 * 
 * map.set("name", "John");
 * 
 * let keys = map.keys();
 * 
 *  Error: keys.push is not a function
 *  Ошибка: keys.push -- это не функция
 * keys.push("more");
 * 
 * Почему? Что нужно поправить в коде, чтобы вызов keys.push сработал?
 */

let map = new Map();

map.set("name", "John");

let keys = Array.from(map.keys())

keys.push("more");

console.log(map)
console.log(keys)